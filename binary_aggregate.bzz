# Attempts to reproduce the aggregation behavior with a
# binary sensor like in Gaucci's paper.
# TODO add logging capabilities
# TODO add parameter modifcation/loading

kSENSE_ANGLE = 15*math.pi/180

# Checks to see if a value is within a certain bound
function in_range(val, min, max) {
  return val>=min and val<= max
}

# Checks if the current robot can "see" the given robot
function sense_robot(robot_id, data) {
  return in_range(data.azimuth, -kSENSE_ANGLE, kSENSE_ANGLE)
}

# Aggregate the sensed robots to check if ANY robots are "seen"
function sees_any_robot(rid, data, sees_robot) {
  return data or sees_robot
}

# This function is executed every time you press the 'execute' button
function init() {
  var filepath = string.concat("./logs/robot_",string.tostring(id),".log")
  f = io.fopen(filepath, "w")
  t = 0
}

# This function is executed at each time step
# It must contain the logic of your controller
function step() {
  var robot_sensor_val = neighbors.map(sense_robot).reduce(sees_any_robot, false)
  # Spin in place if a robot is not detected, otherwise approach it
  if (robot_sensor_val) {
    set_wheels(7.0, 10.0)
    set_leds(0,255,0)
  } else {
    set_wheels(-10.0, 10.0)
    set_leds(255,0,0)
  }
  #log(id,",",pose.position.x,",",pose.position.y)
  io.fwrite(f, t,",",pose.position.x,",",pose.position.y)
  t = t+1
}



# This function is executed every time you press the 'reset'
# button in the GUI. It is supposed to restore the state
# of the controller to whatever it was right after init() was
# called. The state of sensors and actuators is reset
# automatically by ARGoS.
function reset() {
  io.close(f)
}

# This function is executed only once, when the robot is removed
# from the simulation
function destroy() {}