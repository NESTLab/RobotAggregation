# Attempts to reproduce the aggregation behavior with a
# binary sensor like in Gaucci's paper.
params = {.vl0=0.7, .vr0=1.0, .vl1=-1.0, .vr1=1.0}

kSENSE_ANGLE = 15*math.pi/180

# Checks to see if a value is within a certain bound
function in_range(val, min, max) {
  return val>=min and val<= max
}

# Checks if the current robot can "see" the given robot
function sense_robot(robot_id, data) {
  return in_range(data.azimuth, -kSENSE_ANGLE, kSENSE_ANGLE)
}

# Aggregate the sensed robots to check if ANY robots are "seen"
function sees_any_robot(rid, data, sees_robot) {
  return data or sees_robot
}

# This function is executed every time you press the 'execute' button
function init() {
  var filepath = string.concat("./logs/robot_",string.tostring(id),".log")
  f = io.fopen(filepath, "w")
}

# This function is executed at each time step
# It must contain the logic of your params
function step() {
  var robot_sensor_val = neighbors.map(sense_robot).reduce(sees_any_robot, false)
  # Spin in place if a robot is not detected, otherwise approach it
  scale = 20
  if (robot_sensor_val) {
    set_wheels(scale * params.vl0, scale * params.vr0)
    set_leds(0,255,0)
  } else {
    set_wheels(scale * params.vl1, scale * params.vr1)
    set_leds(255,0,0)
  }
  f.fwrite()
}



# This function is executed every time you press the 'reset'
# button in the GUI. It is supposed to restore the state
# of the params to whatever it was right after init() was
# called. The state of sensors and actuators is reset
# automatically by ARGoS.
function reset() {
}

# This function is executed only once, when the robot is removed
# from the simulation
function destroy() {}
